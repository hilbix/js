#!/bin/bash
#
# vim: ft=bash :
#
# A simple shell based macro expander.
# THIS IS NOT SAFE TO UNTRUSTED INPUT!
#
# First character of the line defines what to do:
#
# #	comment, ignored
# :name	define macro
# !name	set input for macro
# @name	run macro
#
# The macro is defined as a shell function.
# The macro lines (:) are appended to each other for this.
#
# Macros with ':' in their name use input from everything before this ':',
# so you can parse input multiply with different macro commands.
#
# Input is gathered until the macro is invoked.  Input which comes later
# is appended for later macro calls.
#
# Usage: unroll.sh input input input > output

STDOUT() { printf '%q' "$1"; printf ' %q' "${@:2}"; printf '\n'; }
STDERR() { STDOUT "$@" >&2; }
OOPS() { STDERR OOPS: "$@"; exit 23; }
D() { STDERR DEBUG: "$@"; }
D() { :; }

declare -A MACROS
macro_set()
{
  D macro_set "$@"
  read -r name cmd <<<"$1" || OOPS cannot parse macro name: "$1"
  MACROS["$name"]="${MACROS["$name"]}"$'\n'"$cmd"
}

declare -A INPUTS
input_add()
{
  D input_add "$@"
  read -r name cmd <<<"$1" || OOPS cannot parse input: "$1"
  INPUTS["$name"]="${INPUTS["$name"]}"$'\n'"$cmd"
}

macro_run()
{
  D macro_run "$@"
  read -r name <<<"$1" || OOPS invalid macro name: "$1"

  IN="${INPUTS["${name%%:*}"]}"
  [ -n "$IN" ] || OOPS missing input 'for' "$name"

  macro="${MACROS["$name"]}"
  [ -n "$macro" ] || OOPS missing macro "$name"

  macro() { . <(echo "$macro"); } || OOPS macro definition fails;

  while read -ru6 line
  do
        [ -n "$line" ] || continue
        read -ra args <<<"$line"
        macro "${args[@]}"
  done 6<<<"$IN"
}

STDOUT // DO NOT EDIT. Automatically generated by "$0" "$@"
STDOUT // src $(sha256sum -- "$@")
while IFS= read -ru6 line
do
        case "$line" in
        ('#'*)		continue;;
        (':'*)		macro_set "${line#':'}";;
        ('!'*)		input_add "${line#'!'}";;
        ('@'*)		macro_run "${line#'@'}";;
        ('')		;;
        (*)		echo "$line";;
        esac <&6-
done 6< <(cat -- "$@")

