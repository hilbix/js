# !! THIS CODE IS NOT MEANT TO BE KEPT COMPATIBLE TO ES12 OR BELOW !!
# (You can BABEL and Polyfills of course.  See generated md5.js)
#
# This code is parsed through ./unroll.sh to output the real JS.
# TBD: It runs on Big endian, too, but is a bit slower due to swap.
#
# vim: ft=javascript :
#
# I need small and fast code, which must not carry any Copyright,
# and which runs in non-HTTPS-context, too.
# Hence this here is free as in free beer, free speech and free baby.
#
# Based on the reference C code of SHA256 handed
# (hence without copyright) analogous to my md5 variant
# and possibly some ideas found elsewhere.

'use strict';
// This is free as in free beer, free speech and free baby.
// IMPORTANT!  NEVER COVER THIS CODE WITH A COPYRIGHT
// as this might break German Urheberrecht!
// If you need to state a Copyright, excempt this code from it!
//
// How to use?
//	<script src="sha1.js"></script>
// then
//	const sha1 = SHA1.sha1('string');
// or
//	const sha1s = new SHA1();
//	const a = sha1s.init().update_str('str1').update_str('str2').end().$hex;
//	const b = sha1s.init().update8(new UInt8Array(something))   .end().$bin;
// This can be repeated:        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

const SHA1 = (_=>_())(() => {

  function D(...a)
    {
      const p = [];
      for (const x of a)
        {
           if ('string' === typeof x)
             p.push(x);
           else if (typeof x !== 'object')
             p.push(`${Number(x>>>0).toString(16)}`.padStart(8,'0'));
           else if (x.BYTES_PER_ELEMENT)
             p.push(Array.from(x).map(_ => _.toString(16).padStart(x.BYTES_PER_ELEMENT*2, '0')).join('_'));
           else
             p.push(JSON.stringify(x));
        }
      console.log(p.join('\n'));
      console.log('-------');
    }

  // Class layout analogous to md5c.js.in, for additional comments see there.
  // I need a stable independent reference code without additional dependencies.
  // Hence no inheritance (yet).  Perhaps future will bring a modular version.
  class SHA1
    {
    big_endian()
      {
        const b	= new ArrayBuffer(4);

        new Uint32Array(b)[0]	= 0x12345678;
        return new Uint8Array(b)[0] === 0x12;
      }
    constructor()
      {
        const b		= new ArrayBuffer(64);
        this.in8	= new Uint8Array(b);
        this.in32	= new Uint32Array(b);

        this.enc	= new TextEncoder();

        this.trafo	= this._trafo;
        if (!this.big_endian())
          this.swap	= this._swap;
      }
    _swap(a32)
      {
        for (let i = a32.length; --i>=0; )
          {
            let x	= a32[i];
            x = ((x>> 8) & 0x00ff00ff) | ((x<< 8) & 0xff00ff00);
            x = ((x>>16) & 0x0000ffff) | ((x<<16) & 0xffff0000);
            a32[i]	= x;
          }
      }

///////////////////////

!ctx	a 0
!ctx	b 1
!ctx	c 2
!ctx	d 3
!ctx	e 4

!var	0
!var	1
!var	2
!var	3
!var	4
!var	5
!var	6
!var	7
!var	8
!var	9
!var	10
!var	11
!var	12
!var	13
!var	14
!var	15

!def	16
!def	17
!def	18
!def	19

!F0	 0
!F0	 1
!F0	 2
!F0	 3
!F0	 4
!F0	 5
!F0	 6
!F0	 7
!F0	 8
!F0	 9
!F0	10
!F0	11
!F0	12
!F0	13
!F0	14
!F0	15

!F1	16
!F1	17
!F1	18
!F1	19

!F2	20
!F2	21
!F2	22
!F2	23
!F2	24
!F2	25
!F2	26
!F2	27
!F2	28
!F2	29
!F2	30
!F2	31
!F2	32
!F2	33
!F2	34
!F2	35
!F2	36
!F2	37
!F2	38
!F2	39

!F3	40
!F3	41
!F3	42
!F3	43
!F3	44
!F3	45
!F3	46
!F3	47
!F3	48
!F3	49
!F3	50
!F3	51
!F3	52
!F3	53
!F3	54
!F3	55
!F3	56
!F3	57
!F3	58
!F3	59

!F4	60
!F4	61
!F4	62
!F4	63
!F4	64
!F4	65
!F4	66
!F4	67
!F4	68
!F4	69
!F4	70
!F4	71
!F4	72
!F4	73
!F4	74
!F4	75
!F4	76
!F4	77
!F4	78
!F4	79

:F0	t = (v$1 + ((a << 5) | (a >>> 27)) + e + ((b & c) | (~b & d)) + 0x5a827999 )|0;
:F0	e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t;

:F1	t = v$[$1 - 3] ^ v$[$1 - 8] ^ v$[$1 - 14] ^ v$[$1 - 16];
:F1	v$1 = (t << 1) | (t >>> 31);
:F1	t = (v$1 + ((a << 5) | (a >>> 27)) + e + ((b & c) | (~b & d)) + 0x5a827999 )|0;
:F1	e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t;

:F2	t = v$[$1 - 3] ^ v$[$1 - 8] ^ v$[$1 - 14] ^ v$[$1 - 16];
:F2	v$1 = (t << 1) | (t >>> 31);
:F2	t = (v$1 + ((a << 5) | (a >>> 27)) + e + (b ^ c ^ d) + 0x6ed9eba1 )|0;
:F2	e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t;

:F3	t = v$[$1 - 3] ^ v$[$1 - 8] ^ v$[$1 - 14] ^ v$[$1 - 16];
:F3	v$1 = (t << 1) | (t >>> 31);
:F3	t = (v$1 + ((a << 5) | (a >>> 27)) + e + ((b & c) | (b & d) | (c & d)) - 0x70e44324 )|0;
:F3	e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t;

:F4	t = v$[$1 - 3] ^ v$[$1 - 8] ^ v$[$1 - 14] ^ v$[$1 - 16];
:F4	v$1 = (t << 1) | (t >>> 31);
:F4	t = (v$1 + ((a << 5) | (a >>> 27)) + e + (b ^ c ^ d) - 0x359d3e2a )|0;
:F4	e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t;

:ctx	let $1 = ctx[$2];
:ctx:	ctx[$2] = ctx[$2] + $1 | 0;

:var	let v$1 = buf[$1] | 0, v$[20 + $1], v$[40 + $1], v$[60 + $1];
:def	let v$1,               v$[20 + $1], v$[40 + $1], v$[60 + $1];

    _trafo()
      {
        const ctx	= this.buf;
        const buf	= this.in32;
	let n, t;

@	var
@	def
@	ctx
@	F0
@	F1
@	F2
@	F3
@	F4
@	ctx:

        this.len	+= 64;
      }

    init()
      {
        this.buf	= new Uint32Array([ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ]);

        this.fill	= 0;	// fill state of this.in
        this.len	= 0;	// total bytes transformed into hash so far
        return this;
      }

    end()
      {
        let pos		= this.fill;
        const len	= (this.len + pos)*8;	// bytes
        const in8	= this.in8;
        const in32	= this.in32;

        // there is at least 1 byte free in this.in8
        in8[pos]	= 0x80;

        let rest	= 64-1-pos;
        // The last 8 byte of the block will be overwritten below
        for (let i=rest; --i>=0; in8[++pos]=0);
        if (this.swap) this.swap(this.in32);
        if (rest<8)
          {
            this.trafo();
            for (let i=14; --i>=0; in32[i]=0);
          }
        in32[14]	= len / 0x100000000 | 0;	// we cannot use integer math here
        in32[15]	= len >>>0;
        this.trafo();

        this.fill	= void 0;
        this.len	= void 0;
        // this.buf contains the result
        if (this.swap) this.swap(this.buf);
        return this;
      }

//////////////////////

    update8(b)			// Uint8Array
      {
        const _	= this.in8;

        let out	= this.fill | 0;
        let len	= b.length | 0;	// we do not support more than 2^32 bytes (AKA 4GiB) per update
        let pos	= 0;

        while (len)
          {
            let max	= 64-out | 0;
            if (max > len)
              max	= len | 0;

            // To avoid the swap() on Big endian machines, following copy
            // should rather be replaced by some inlined Duff's device.
            // (for this we need to add up/down-counting repeats to ./unroll.sh)
            // (and we probably need conditional macros as well as recursive ones)
            _.set(b.subarray(pos, pos+max), out);

            pos	= pos + max | 0;
            out	= out + max | 0;
            len	= len - max | 0;
            if (out<64)
              break;
            if (this.swap) this.swap(this.in32);
            this.trafo();
            out	= 0;
          }
        this.fill	= out;
        return this;
      }
    update_str(s)		// this is not meant for long strings!
      {
        return this.update8(this.enc.encode(s));
      }
    get $bin()
      {
        return new Uint8Array(this.buf.buffer);
      }
    get $hex()
      {
        return Array.from(this.$bin, b => b.toString(16).padStart(2, '0')).join('');
      }
    static sha1(s,bin)
      {
        const out = sha1.init().update_str(s).end();
        return bin ? out.$bin : out.$hex;
      }
    static test(d,t)
      {
        const r = this.sha1(t);
        if (r !== d)
          throw `sha1c.js test failed for '${t}':\n'${d}' expected\n'${r}' got`;
//        D('test ok', r);
      }

    };

  const sha1 = new SHA1();	// for the static sha256 above

  SHA1.test('da39a3ee5e6b4b0d3255bfef95601890afd80709', '');									// 0 bytes
  SHA1.test('accfa188bccab15065e9feaf805d00217e958ec0', '0123456789abcdef0123456789abcdef0123456789abcdef0123456');		// single round
  SHA1.test('edc9055eaab6e86d803e41dd99272b3da1468595', '0123456789abcdef0123456789abcdef0123456789abcdef01234567');		// double round
  SHA1.test('ce4303f6b22257d9c9cf314ef1dee4707c6e1c13', '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef');	// 64 byte input
//  console.log('selftest ok');
  return SHA1;
});
